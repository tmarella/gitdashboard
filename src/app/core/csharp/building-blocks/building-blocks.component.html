<h1>Building Blocks
    <div class="btn-group pull-right" role="group">
        <button type="button" class="btn btn-outline-secondary">Share</button>
        <button type="button" class="btn btn-outline-secondary">Export</button>
    </div>
</h1>
<hr>
<table class="table table-condensed border" style="width: 100%; font-size: 15px;">
    <tbody>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">class</td>
            <td style="width: 70%; border: 0;">class is a group of related methods and variables. we can say it is a
                Blueprint of an object.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">partial class</td>
            <td style="width: 70%; border: 0;">Splits the definition of a class/method/struct/interface over 2 or
                more class files.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">Interface</td>
            <td style="width: 70%; border: 0;">Like a class, Interface can have methods, properties, events, and
                indexers as its members. But interfaces will contain only the declaration of the members.(By
                Default, All members are private and abstract)</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">object</td>
            <td style="width: 70%; border: 0;">object is an entity that has state(data) and behavior(method).</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">field</td>
            <td style="width: 70%; border: 0;">field is a class-level variable that holds a value.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">variable</td>
            <td style="width: 70%; border: 0;">variable is a container for storing data values.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">property</td>
            <td style="width: 70%; border: 0;">property is an extension to field.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">constructor</td>
            <td style="width: 70%; border: 0;">constructor is a special method of the class which gets automatically
                invoked whenever an instance of the class is created.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">method</td>
            <td style="width: 70%; border: 0;">method is a code block that contains a series of statements.</td>
        </tr>
        <tr>
            <td class="border-right font-weight-bold" style="width: 10%; border: 0;">namespace</td>
            <td style="width: 70%; border: 0;">namespace is a container which consists of other namespaces, classes,
                etc.</td>
        </tr>
    </tbody>
</table>
<hr>
<h5>Interface</h5>
<p>Advantages</p>
<ul>
    <li>It is used to achieve loose coupling. </li>
    <li>It is used to achieve total abstraction. </li>
    <li>To achieve multiple inheritance and abstraction. </li>
    <li>Interfaces add a plug and play like architecture into applications</li>
</ul>
<p>Syntax</p>
<li style="padding-left: 20px; display: block;">
    <pre>{{interaceSyntax}}</pre>
</li>
<hr>
<h5>SOLID principles</h5>
<ul>
    <li>SRP The Single Responsibility Principle: — a class should have one, and only one, reason to change, meaning
        that a class should have only one job.</li>
    <li>OCP The Open Closed Principle: — you should be able to extend a class’s behavior, without modifying it.</li>
    <li>LSP The Liskov Substitution Principle: — If any module is using a Base class then the reference to that Base
        class can be replaced with a Derived class without affecting the functionality of the module.</li>
    <li>ISP The Interface Segregation Principle: — make fine grained interfaces that are client specific.</li>
    <li>DIP The Dependency Inversion Principle — depend on abstractions not on concrete implementations.</li>
</ul>